import pytest

from func import es_primo

# Generated by Qodo Gen

import pytest

class TestEsPrimo:

    # Testing with prime numbers (e.g., 2, 3, 5, 7, 11, 13, 17, 19) returns True
    def test_prime_numbers_return_true(self):
        prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19]
        for num in prime_numbers:
            assert es_primo(num) is True, f"{num} should be identified as prime"

    # Testing with 0 returns False
    def test_zero_returns_false(self):
        assert es_primo(0) is False, "0 should not be identified as prime"

    # Testing with non-prime numbers (e.g., 4, 6, 8, 9, 10, 12) returns False
    def test_non_prime_numbers_return_false(self):
        non_prime_numbers = [4, 6, 8, 9, 10, 12]
        for num in non_prime_numbers:
            assert es_primo(num) is False, f"{num} should not be identified as prime"

    # Testing with integer 2 returns True
    def test_integer_2_returns_true(self):
        assert es_primo(2) is True, "2 should be identified as prime"

    # Testing with large prime numbers (e.g., 997, 1009) returns True
    def test_large_prime_numbers_return_true(self):
        large_prime_numbers = [997, 1009]
        for num in large_prime_numbers:
            assert es_primo(num) is True, f"{num} should be identified as prime"

    # Testing with float values that are exactly integers (e.g., 5.0, 7.0) works correctly
    def test_float_values_as_integers(self):
        float_values = [5.0, 7.0, 11.0, 13.0]
        for num in float_values:
            assert es_primo(num) is True, f"{num} should be identified as prime"

    # Testing with 1 returns False
    def test_one_is_not_prime(self):
        assert es_primo(1) is False, "1 should not be identified as prime"

    # Testing with negative numbers returns False
    def test_negative_numbers_return_false(self):
        negative_numbers = [-1, -2, -3, -10, -100]
        for num in negative_numbers:
            assert es_primo(num) is False, f"{num} should not be identified as prime"

    # Testing with boolean values (True/False) raises TypeError
    def test_boolean_values_raise_typeerror(self):
        boolean_values = [True, False]
        for value in boolean_values:
            with pytest.raises(TypeError, match="El argumento debe ser un número entero"):
                es_primo(value)

    # Testing with float values that are not close to integers raises TypeError
    def test_float_values_not_close_to_integers_raise_typeerror(self):
        float_values = [2.5, 3.1, 4.9999999999, -1.7]
        for num in float_values:
            with pytest.raises(TypeError, match="El argumento debe ser un número entero"):
                es_primo(num)

    # Testing with non-numeric types (strings, lists, etc.) raises TypeError
    def test_non_numeric_types_raise_typeerror(self):
        non_numeric_inputs = ["string", [1, 2, 3], {"key": "value"}, (1, 2), None]
        for input_value in non_numeric_inputs:
            with pytest.raises(TypeError):
                es_primo(input_value)

    # Testing with very large numbers to check performance
    def test_large_numbers_performance(self):
        large_prime = 9999999967  # A known large prime number
        assert es_primo(large_prime) is True, f"{large_prime} should be identified as prime"

    # Testing with None as input raises TypeError
    def test_none_input_raises_typeerror(self):
        with pytest.raises(TypeError):
            es_primo(None)

    # Testing with empty input (no arguments) raises an error
    def test_empty_input_raises_error(self):
        with pytest.raises(TypeError):
            es_primo()

    # Testing with numbers at the boundary of int/float precision
    def test_boundary_of_int_float_precision(self):
        numbers = [19.000000000000004, 2.9999999999999996, 5.000000000000001]
        expected_results = [True, True, True]
        for num, expected in zip(numbers, expected_results):
            assert es_primo(num) is expected, f"{num} should be identified as {'prime' if expected else 'not prime'}"
